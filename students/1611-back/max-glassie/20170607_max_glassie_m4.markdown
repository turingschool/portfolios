# Max Glassie - M3 Portfolio

## Areas of Emphasis
The feel of this module was very different from previous modules. I've struggled since being sick the first week but I'm proud of how I committed to showing up and putting in the work.   

I'm very happy with the intellectual growth that I made. The key challenge of this module was to learn a new language (JavaScript) and to be able to use that language to move data from a SQL database all the way up to the DOM. I am very interested in being able to build dashboards and so I'm very happy with the opportunity to experience the entire flow of data through a system.

I'm also happy that the systems and processes that we've learned in Ruby and Rails apply to other languages and frameworks. It confirms my theory that most of the value Turing provides is deeper than the tools we are using.

While JavaScript is a weird and messy (multi-paradigm) language, I've decided that because of the practicality and the power I will invest heavily in learning how to use the language. I admit that I didn't want to like JS but it's growing on me. Node and Express is more functional and more customizable than Rails and I'm attracted to that combination.

I'm also very happy and surprised with how well Armstrong went this module. Our first three weeks, we had over 20 people and we produced some really high quality Spike sessions. We've engaged with the community and the posse is has all the potential to continue growing without my guidance, pursuing an interesting and exciting technology in blockchain.  

I'm excited for module 5. I'm planning to work on JavaScript and Solidity primarily, with my fun programming time dedicated to learning Clojure. My first language was LISP and I want to learn a production LISP and I have some wonderful books on how to do it. I'm also very excited for the opportunity to talk to more people who love programming and commit myself more fully to my athletic training. It's going to be really fun. I'm ready to launch (after a good sleep).

## Rubric Scores

* **A: End-of-Module Assessment**: 3
* **B: Individual Work & Projects**: 3
* **C: Group Work & Projects**: 4
* **D: Professional Skills**: 3
* **E: Feedback & Community Participation**: 4

-----------------------

## A: End of Module Assessment

This was really challenging for me. I knew that I was not prepared for the second half of the assessment in terms of what I needed to do in JavaScript.

For various reasons, I hadn't had enough practice on front end JS during the module and so I studied all weekend prior to the final to make sure I could actually do all the things that were required.

I didn't want to be in a situation on the final where I had to do something I'd never done before. I happy with how that preparation paid off. There was a lot to do but little was completely new.

On a higher level, it's an amazing thing that I am capable of writing these two apps, using Ruby / Rails and JS, and have them successfully communicate with each other. I'm so delighted with what I've learned at Turing.  


##### 1. Satisfactory Progress

* 4: Developer completes sections 1 through 5 with no bugs and has one or more supporting feature implemented.
* **3: Developer completes sections 1 through 5 minor bugs and no missing functionality.**
* 2: Developer completes sections 1 through 5 with some _minor_ bugs or missing functionality.
* 1: Developer fails to complete sections 1 through 5 or there are significant issues with delivered functionality.

_Links are not scoped to the user that’s logged in. There’s some kinks with the “hot” and “top link” displaying next to the link itself. You don’t want to be sending data to Hot Reads if the user is pressing the “unread” button - I think it’s fine to only send the data if the user is marking the link as “read.” Although these are both pretty big bugs, I believe you could finish this up given some more time._

##### 2. Ruby & Rails Style & API

* 4: Developer is able to craft Rails features that follow the principles of MVC, push business logic down the stack, and skillfully utilizes ActiveRecord to model application state. Developer can speak to choices made in the code and knows what every line of code is doing.
* 3: Developer generally writes clean Rails features that make smart use of Ruby, with some struggles in pushing logic down the stack. The application displays good judgement in modeling the problem as data. Developer can speak to choices made in the code and knows what every line of code is doing.
* 2: Developer struggles with some concepts of MVC.  Developer is not confident in what every line of the code is doing or cannot speak to the choices made.
* 1: Developer struggles with MVC and pushing logic down the stack
* 0: Developer shows little or no understanding of how to craft Rails applications

_Love that you extracted out the "top ten" and other methods to the model level in Hot Reads. You’re following Rails conventions. I’d love to see more authorization for your edit/update actions in your Url Lockbox LinksController. Good work with your Rails code._

##### 3. Javascript Syntax & Style

* 4: Developer uses elegant and idiomatic Javascript to accomplish common tasks. Demonstrates solid understanding of function passing and manipulation. Developer can speak to choices made in the code and knows what every line of code is doing.
* **3: Developer writes solid Javascript code using common patterns and idioms. Code is organized appropriately within objects and functions. Developer can speak to choices made in the code and knows what every line of code is doing.**
* 2: Developer can accomplish basic tasks with Javascript but implementation is largely copy/pasted or non-idiomatic. Developer is not confident in what every line of the code is doing or cannot speak to the choices made.
* 1: Developer can manipulate Javascript syntax but implementation is buggy or inconsistent.
* 0: Developer shows little or no understanding of Javascript syntax and idioms

_Love that you’re using a constructor function/class for Link. You’ve divided the functionality into small functions and organized your code logically in files. You’re heavily using vanilla JS rather than leveraging the power of jQuery, which is totally fine if that’s you’re approach. I think being able to do it both ways is a great idea. Good work with the JS._

##### 4. Testing

* 4: Developer excels at taking small steps and using the tests for *both* design and verification. Developer uses integration tests, controller tests, and model tests where appropriate.
* **3: Developer writes tests that are effective validation of functionality, but don’t drive the design. Developer uses integration tests, controller tests, and model tests where appropriate.**
* 2: Developer uses tests to guide development, but implements more functionality than the tests cover. Application is missing tests in a needed area such as model, integration, or controller tests.
* 1: Developer is able to write tests, but they’re written after or in the middle of implementation.
* 0: Developer does not use tests to guide development.

_Your tests look good. You’ve tested sad paths and have a high test coverage._

##### 5. User Interface

* 4: The application is pleasant, logical, and easy to use
* **3: The application has many strong pages/interactions, but a few holes in lesser-used functionality**
* 2: The application shows effort in the interface, but the result is not effective
* 1: The application is confusing or difficult to use

_User interface looks solid. The bugs with top/hot links are distracting._

##### 6. Documentation

* 4: Project features excellent documentation showing how to develop the application including a screencast or tutorial
* **3: Project features excellent documentation showing how to develop the applications**
* 2: Project features barebones documentation showing how to get the dev environment up and running
* 1: Project has insufficient documentation

_I’d love to see even more directions in your Url Lockbox README, but both README’s give a good overview of how the app works._

##### 7. Workflow

* 4: The developer effectively uses Git branches and many small, atomic commits that document the evolution of their application.
* **3: The developer makes a series of small, atomic commits that document the evolution of their application. There are no formatting issues in the code base.**
* 2: The developer makes large commits covering multiple features that make it difficult for the evaluator to determine the evolution of the application.
* 1: The developer committed the code to version control in only a few commits. The evaluator cannot determine the evolution of the application.
* 0: The application was not checked into version control.

_Good work_

## B: Individual Work & Projects

##### Open Source

I ended up really enjoying this project. In my initial research, I was really frustrated because I had a lot of trouble finding a reasonable project. I found after exploring the codebases the issues were mostly over my head, especially given time constraints.

I ended up switching my approach and explored the Faker gem. I'd never seen the code for a gem before.

It's possible to set a "locale" which will enable the app to automatically translate into another language. I was delighted to discover that I could support the project by providing additional Chinese language support for the translation - it did not have university names.

It was a cool way to combine two interests in my life which are closely related. Learning Chinese was phenomenal intellectual preparation for learning to program. They both involve learning new vocabulary, precise syntax, attention to detail, persistence, and above all, humility.

It was a wonderful way to experience first-hand how a community of developers can maintain software. And how someone random on the internet can add a little piece of code that enables just a little more functionality for the user.

Bugs especially are interesting... it's like the scientific method in action. I observed this thing, can you reproduce this thing? If yes, why'd it happen? If no, then maybe we shouldn't worry about this. It's cool to see a community of people, who may not know each other, follow a process to build and maintain a thing.   

* [GitHub Open Source Contribution Pull Request URL](https://github.com/stympy/faker/pull/938)
* [GitHub Bug Identifying Pull Request URL](https://github.com/pry/pry/issues/1614)
* [Original Assignment](http://backend.turing.io/module4/lessons/contributing_to_open_source)

## C: Group Work & Projects

#### Quantified Self

This was a very frustrating and ultimately very valuable learning experience. Spencer and I have very different work styles. I'm very methodical and process oriented whereas he's more run and gun. But we both committed to putting in the work and despite initial struggles with JavaScript through consistent effort and organization we were able to achieve the learning goals for the project.

In two weeks we built an API and served that data to a front end in a new language and we were able to do that successfully. Learning those skills in Ruby / Rails took months - we really discovered that we can use the conceptual foundations we learned in Rails to learn new frameworks and languages.

We’re proud of our work ethic: we worked Saturdays and late into the night everyday, and were consistent with our efforts. We grew as a partnership, in terms of we got better at working together and also improved technically.

We did a good job communicating to our instructors when we were struggling and ensuring that there was an open conversation about the best way for us to meet the key learning goals of the project.

I'm proud of Spencer. I challenged him in two ways - one, to be a leader organizationally for our team, and two, to be more positive and to take better care of himself. I'm grateful to say that he stepped up to these challenges, really took them to heart.

* [Quantified Self Front End - GitHub URL](https://github.com/maxglassie/quantified-self-front-end)
* [Quantified Self Back End - GitHub URL](https://github.com/scmountain/Quantified-Self)
* [Quantified Self Production](https://maxglassie.github.io/quantified-self-front-end/)
* [Quantified Self Original Assignment](http://backend.turing.io/module4/projects/quantified-self/quantified-self)
* [Quantified Self Reflection](https://gist.github.com/maxglassie/917678b8eb805a292af4c99f6de1b46b)

##### Rubric

You will be subjectively graded by an instructor on the following criteria:

##### Specification Adherence

- 4: Application implements all functionality as defined, with no bugs, and one extension
- **3: Application implements all functionality as defined, but some bugs or strange behavior where features intersect**
- 2: Application is missing required functionality, deviates significantly from the spec, or serious bugs prevent features from being usable
- 1: Application is missing a significant portion of functionality

_You did not achieve full functionality, but you communicated your timeline continuously throughout the project._

##### Planning and Design

- 4: Team created visual schema, API documentation and user stories, before writing tests. API adheres to REST standard.
- 3: Team created either a schema or API docs to facilitate implementation of a service.
- **2: Team has some notes on how to implement their service, but someone else couldn't implement it.**
- 1: Team did not design their service.

_The project does not have API documentation to provide someone with the resources/knowledge to use your API._

##### Testing

- 4: All functionality is covered by tests. Appropriate mix of unit and integration tests. Sad path testing in both unit and integration tests.
- **3: All back-end functionality is covered by tests. Front-end uses unit tests wherever logic can be separated from interface and network requests.**
- 2: More back-end functionality implemented than tested and/or very little front-end testing
- 1: Team fails to effectively test the application.

_Even though you didn't really get to frontend testing, you made a solid effort to get it up and running and setup. Your backend tests looks good!_

##### HTML/UI

- 4: Team put some effort into styling. HTML features unique IDs, classes and data attributes for DOM traversal.
- 3: Application is not confusing to use. HTML classes and IDs are kebab case.
- **2: HTML is greatly lacking in standards compliance. UI is confusing or very buggy.**
- 1: Application is unusable

_When I first opened your app, I wasn't sure how to test the required functionality. I then clicked on one of the food names and saw the functionality. It isn't easy to understand how to work your application. It's also a little buggy - the alert wouldn't stop popping up at one point._

##### JS syntax and Style

- 4: Javascript features explicit DOM traversal (not using closest), demonstrates great OOP concepts, and uses named and anonymous functions when appropriate
- **3: Code logically divided into files. Developer can show examples of some SOLID concepts. Attention payed to indentation and naming.**
- 2: Javascript is noticeably lacking in the above concepts.
- 1: Team has not applied any style concepts from class or from Ruby background

_There is room for improvement here, but in general, you've attempted to break things down and write clean code. You're following JS conventions and did your best to implement OOP. You can break some of your functions down further to make them more single responsibility._

##### Git Workflow

- 4: Team uses master for production, and creates a feature branch for each card worked on. Team is using pull requests with good context and conversation
- **3: Team is using the feature branches for small groups of cards, and has a pull request for each feature. Developers that aren't on the team have commented on PRs.**
- 2: Team fails to use feature branches, or isn't using pull requests
- 1: All code is committed to master

_You're using git and PR's for each feature.  You're commenting on PR's and giving each other feedback. I would like to see you commit more often in the future!_

##### Project Management

- 4: Team is using a project management tool and updating their progress daily. Team is approving each other's  work. Team is documenting conversations and conclusions on relevant cards.
- **3: Team is using a project management tool to keep their project organized.**
- 2: Team is using a project management tool but didn't update the progress frequently. Many cards have no changes made to them
- 1: Team failed to use a project management tool to track its progress.


## The Howler: Robot With Attitude

This was a very interesting project for me. The codebase was complex but quite linear, meaning it moved from point A to point B. There was very little modularity in it and at first we ran into trouble because there just wasn't enough code for five developers.

I'm not sure how well I did as Product Owner. I definitely did my best to shape the overall design of the functionality and communicate with Bob, who was acting as our client. I felt like on the whole I played the part well, in terms of being conservative in estimating what we would be capable of.

I will admit that I initially opposed the idea of the Chrome Extension, even though the team was jazzed up about it. I thought it would be tricky. There were enough unknown variables there that I thought it would be a long shot that we could deliver it.

I wasn't that thrilled even in how the functionality would be beneficial to the user. I was trying to steer the team and the client away from it.

However, the client wanted the Chrome extension. I was then quite surprised that no one else wanted to touch it. So I ended up diving into that piece individually.

It ended up being quite an interesting and creative intellectual challenge and I enjoyed it. Spencer knew that it's a good thing to put me on one piece of functionality that needs a few good days of experimenting to get moving and I'm happy in that space, so he helped put me there. I also felt like it was my responsibility as product owner to push forward the key piece of functionality that the client wanted.

Our group ended up working really well together, after some initial storming. We challenged Spencer to lead and he stepped up and did a great job. He managed feelings and egos and showed up and did the administrative and organizational work to make the project a success.

While admittedly a number of our team missed demos, I felt that overall that it was a very successful project. We did well communicating with the client, managing ourselves as professionals, and actually delivering something pretty cool.

I have written extensively on Armstrong posse below as a make-up for missing demos.  


* [The Howler - GitHub URL](https://github.com/CjMoore/howler)
* [The Howler Chrome Extension - GitHub URL](https://github.com/CjMoore/howler-extension)
* [Original Assignment](http://backend.turing.io/module4/capstone_project_overview)
* [The Howler Production](https://the-howler.herokuapp.com/)

###### 1. Project Management

*   4: Tracker also documents feature related discussions
*   **3: Team is using well formatted user stories and moving cards through each status in realtime**
*   2: Team has used Tracker as a respository of information
*   1: Tracker shows little to no use

###### 2. Completion & Pace

*   **4: Team is proactive in understanding scope and is able to commit to stories before starting the sprint**
*   3: Team is able to set and update expectations so that there are no surprises on the last day of the sprint
*   2: Team does not have agreed upon stories completed at the end of the sprint, but has a plan to get them done
*   1: Team does not have agreed upon stories completed, and has no plan to complete them

###### 3. Implementation Quality

*   4: Project demonstrates exceptionally well factored code.
*   **3: Project exhibits maintainable well divided code. Developers are able to speak to architecture and implementation decisions.**
*   2: Project demonstrates some gaps in code quality and/or developers cannot defend their decisions.
*   1: Project demonstrates poor factoring and/or understanding of MVC.

###### 4. Application of Techniques

*   4: Project has implemented two or more major techniques that were new this week.
*   **3: Project has implemented one major technique that was new this week.**
*   2: Project has a implementation in progress of one major technique that has not been previously attempted.
*   1: Project does not implement new techniques.

###### 5. Documentation

*   4: Project also features a screencast, tutorial or other wow factor
*   **3: Project features easy to navigate documentation showing how to setup and contribute to the application**
*   2: Project features barebones documentation showing how to get the dev environment up and running
*   1: Project has insufficient documentation

###### 6. Accessibility

*   4: Team has expertly implemented features to follow accessibility best practices.
*   **3: Team has implemented code to increase accessibility.**
*   2: Team has considered accessibility issues but has not yet produced code to address them.
*   1: Team has not considered accessibility issues.

## D: Professional Skills
I worked really hard to make a great resume that I can be happy and proud to share with others. I frequently communicate with Meg, who I see as a fantastic resource. I've been going to her office hours since Module 2 and our conversations have been really helpful to me.

* [Professional Development Deliverables](https://github.com/turingschool/career-development-curriculum/blob/master/deliverable_submissions/1611-b/max_glassie.markdown)

## E: Community Participation

### Gear-Up

I co-lead a Gear Up with Courtney, Dan, and Ryan. This topic sprung in part from a heated discussion Courtney and I had previously about the ethics behind Edward Snowden's decision to become a whistleblower and how he did it.

I wrote the session description, with the strategy of "clickbait with integrity." The response was popular enough that they had to cap our session at 18 people:


_Privacy vs Security: If You Were In Snowden's Shoes, Would You Be A Hero (or Traitor)? <br>

What would I do when presented with the facts of the U.S. security apparatus' surveillance capabilities? What would I have done? We'll look at the debate between security and privacy by putting ourselves in Snowden's shoes. <br

After that, we'll present a case closer to home - how should we use our users data? Is it okay to sell it to advertisers? As developers, we likely will have access to sensitive personal information. What do we do with that power? <br>

Join us for a lively conversation at the heart of what we do as technologists - the ethical (or unethical) use of data._ <br>

This is an important conversation. Our pedagogical goal was to get people thinking about these questions as if we were in Snowden's shoes, as we transition into an industry where we will have privileged access to people's personal data.

Just to think about the subject and plant a seed that this conversation is at the heart of our industry - the ethical use of data - and give us the ability for empathy with one of the more controversial and consequential examples of someone making a decision in line with their conscience in the field of technology.  

### Playing a Part
I made a significant effort this module to contribute to the Turing community. After a conversation in module 1 with Beth and Ilana, who suggested that I lead a spike to help me find other people who had similar intellectual interests to my own, I led two Spikes in Module 2 and one in Module 3.

###### Technical Talk at a Meet Up
This inning I built on those experiences. Courtney and I turned one of the spikes that we gave called "How An Interpreter Works: Looking Under Ruby's Hood" into a honed, 20 minute presentation that we gave at the Denver.rb MeetUp in May, which Andrew Carmer organizes.

We drew from two of our favorite books,  _The Structure and Interpretation of Computer Programs_ (SICP) and _Ruby Under a Microscope_. SICP describes in depth the key concepts for writing a metalinguistic evaluator and we mapped those concepts onto the corresponding functions that the RVM performs in interpreting our Ruby code. We received confirmation from senior engineers at the MeetUp that our technical descriptions were on point. I even talked a little about LISP in there...

###### Armstrong Posse
This module Courtney and I co-lead the Armstrong Posse. I believe in the power of commitment so the previous module I went to every Armstrong spike unless I was giving one.

I volunteered to lead the posse this module, with the strategic intention to simply provide a place and a structure for people to have an initial encounter with blockchain technologies and to build a team around researching this. It's an intellectual fascination of mine that has a lot more sparkle and hype than learning functional programming in Clojure. I knew I could get people interested.

I was quite surprised by how popular the posse turned out to be. For the first three spikes, we had 20+ people at each one. We led two technical tutorials, doing "Hello World" in Solidity development and also a "smart contract" for voting. We also brought in Mike Schutte to talk about application design - how a React front end, a Rails backend, and a Solidity application all communicate with each other.

I was very happy with how our strategies translated to an amazing educational experience for some 20+ people. Building on the "click bait with integrity" theme, we drew crowds. I received significant positive feedback about the posse and how excited people were to learn about blockchain.

Our posse lunches routinely had around 10 people and lively and active discussion. We held a happy hour and had alumni and even a blockchain expert in town for a conference join us. We attended blockchain Meet Ups and began networking with the large community, asking how we can contribute and assist their projects and their efforts to bring people together around this technology.

I articulated our priorities through a set of principles, which I hope will endure and guide decision making for the next leadership.

1) We're a team <br>
2) We believe in the power of commitment <br>
3) We're building community <br>

We demarcate our bullshit line. This is a personal principle of mine that when I start talking beyond my knowledge, I declare it. I may then continue talking, but you at least know it's bullshit.

As a part of these principles I made sure to set a tone that "look, I don't really know anything about blockchain and you don't really either and we're going to research and learn together." Try to bring anything you learn back to the group; that's your responsibility as a member of the team.

In this vein, after the first spike, I actively began to give away leadership as much as possible.

In this, I articulated another principle to the team I call the "Neville Longbottom Principle of Leadership Development": I don't know which person on the team is going to be a hero who cuts off snakes heads, but I do know that most likely it's not going to be who I expect. So the question is how do we create a space where people have the opportunity and the encouragement to grow and contribute in that way?

In this, we had strong participation in our Spikes. We had 4 different people give lightning talks on research they'd discovered. Two people led technical talks of top notch quality. I asked people and challenged them to take leadership roles and what they did amazed me. I was very grateful to provide a space for people - who knows which of them will make a career as a blockchain developer?

Yesterday, I handed leadership off to three students who are actively planning for the next module and I feel have the tools to keep this thing alive. They're taking over and carrying on providing this space for the next group of people. It is awesome to see.

------------------

## Final Review

### Notes

( Leave blanks for reviewers )

### Outcome

( Leave blanks for reviewers )
