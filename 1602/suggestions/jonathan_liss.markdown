Assessed By: Romeeka Gayhart

Notes: Remember that Turing is cramming a lot of knowledge into your head in a really short amount of time - and one of the most effective ways of learning at that speed is trying something, coding yourself into a corner, and then getting the solution later. For that reason, you'll find a lot of stuff like 'in depth unit testing' won't be taught before you need it, but instead, afterwards. It gets frustrating as all hell, but it does work.

You're on the right path with your enthusiasm for digging in and solving/enjoying the puzzle of code.

Keep reading POODR and keep thinking about the 'end user' of your code (not the user of the interface, but the future coder). Name your methods and split/test your code so that Mike can look at your issue and within 10 minutes, at least diagnose _where_ something went wrong (he might need to Google the 'why' - we use Google a lot).

### 1. Functional Expectations

* 4: Application fulfills all base expectations and the one extension

### 2. Test-Driven Development

* 3: Application is well tested but does not balance isolation and integration tests, using only the data necessary to test the functionality

### 3. Encapsulation / Breaking Logic into Components

* 3: Application effectively breaks logical components apart but breaks the principle of SRP

### 4. Fundamental Ruby & Style

* 2:  Application runs but the code has long methods, unnecessary or poorly named variables, and needs significant refactoring

### 5. Looping *or* Recursion

* 4: Application makes excellent use of loop/recursion techniques
